#include <curses.h>
#include <stdio.h>
#include <random>
#include <cmath>
#include <string>

struct Pos {
	int y;
	int x;
};

class Cwin {
private:
	struct Pos pos;
	struct Pos size;
	void AdjustHeight(int h);
	void AdjustWidth(int w);
	
public:
	Cwin();
	Cwin(int h, int w, int y, int x);
	~Cwin();
	void Print();
	void Moveto(struct Pos pos);
	void Shiftx(int x=0);
	void Shifty(int y=0);
	void AdjustSize(int h, int x);
	int Gety();
	int Getx();
};

#define NUM_STATS 7
#define NUM_TALENTS 48
#define NUM_STR_TALENTS 7
#define NUM_DEX_TALENTS 10
#define NUM_CON_TALENTS 7
#define NUM_INT_TALENTS 8
#define NUM_WIS_TALENTS 7
#define NUM_CHA_TALENTS 8
#define NUM_LCK_TALENTS 1

#define SIZE_TALENT_MENU_H 16
#define SIZE_TALENT_MENU_W 24
#define SIZE_SIZE_MENU_H 9
#define SIZE_SIZE_MENU_W 9
#define STAT_MARGIN_Y 4

int rand_num(int min, int max);
char GetUserInp(int argn, ...);
void PrintLevelupPrompt(int y, int x);

enum AppState { STATE_STATS, STATE_TALENTS, STATE_RESET, STATE_EXIT };
enum StatState { STATE_STR, STATE_DEX, STATE_CON, STATE_INT, STATE_WIS, STATE_CHA, STATE_LCK };

class Talent {
private:
	int stat;
	std::string name;
	std::string desc;
	Talent* next;
public:
	Talent();
	Talent(int s, std::string n, std::string d);
	~Talent();
	Talent* GetNext();
	void SetNext(Talent* new_next);
};

class SubTalentTree {
private:
	int stat;
	Talent* head;
public:
	SubTalentTree();
	SubTalentTree(int s);
	~SubTalentTree();
	void AddTalent(std::string name, std::string desc);
	void PrintTalents();
};

class TalentTree {
private:
	SubTalentTree* stt[NUM_STATS];
public:
	TalentTree();
	~TalentTree();
	void PrintWin();
	void AddTalent(int stat, std::string name, std::string desc);
	//void PrintTalentList(int stat);
};

class PlayerCharacter {
private:
	int stat[NUM_STATS];
	int talent_point[NUM_STATS];
	int talents_pointed[NUM_STATS][NUM_TALENTS];
	int level;
	Cwin* stat_win[NUM_STATS];
	Cwin* talent_win;

public:
	PlayerCharacter();
	~PlayerCharacter();
	void Levelup();
	void GenerateTalentPoints();
	void SetStat(int stat, int n);
	int GetLevel();
	int GetStat(int i);
	int GetTalentPoint(int i);
};

Cwin::Cwin() {
	pos = { 0 };
	size = { 5, 5 };
}

Cwin::Cwin(int h, int w, int y, int x) {
	pos = { y, x };
	size = { h, w };
}

Cwin::~Cwin(){}


void Cwin::AdjustHeight(int h) {
	if( h < 2 ){
		size.y = 2;
		return;
	}
	size.y = h;
}

void Cwin::AdjustWidth(int w) {
	if( w < 3 ){
		size.x = 3;
		return;
	} else {
		if( size.x % 2 == 0 ){
			size.x = w + 1;
			return;
		}
	}
	size.x = w;
}

void Cwin::Print() {
	for( int i=0; i<size.y; i++ ){
		for( int j=0; j<size.x; j++ ){
			if( ((j == 0) || (j == size.x - 1)) && (i != 0) )
				mvaddch(pos.y + i, pos.x + j, '|');
			else if( ((i == 0) || (i == size.y - 1)) && ((j != 0) && (j != size.x-1)) )
				mvaddch(pos.y + i, pos.x + j, '_');
			else
				mvaddch(pos.y + i, pos.x + j, ' ');
		}
	}
}

void Cwin::Moveto(struct Pos new_pos) {
	pos = new_pos;
}

void Cwin::Shiftx(int x) {
	pos.x += x;
}

void Cwin::Shifty(int y) {
	pos.y += y;
}

void Cwin::AdjustSize(int h, int w) {
	AdjustWidth(w);
	AdjustHeight(h);
}

int Cwin::Gety() {
	return pos.y;
}

int Cwin::Getx() {
	return pos.x;
}

const int NUM_TALENTS_IN_STAT[] = {NUM_STR_TALENTS, NUM_DEX_TALENTS, NUM_CON_TALENTS, NUM_INT_TALENTS, NUM_WIS_TALENTS, NUM_CHA_TALENTS};

const std::string STAT_NAMES[] = {
	"STR",
	"DEX",
	"CON",
	"INT",
	"WIS",
	"CHA",
	"LCK"
};

const std::string STAT_NAMES_LONG[] = {
	"strength",
	"dexterity",
	"constitution",
	"intelligence",
	"wisdom",
	"charisma",
	"luck"
};

std::random_device rd;
std::mt19937 RNGine(rd());
int rand_num(int min, int max){
	std::uniform_int_distribution<int> rand(min, max);
	return rand(RNGine);
}

char GetUserInp(int argn, ...){
	char userInp;
	while(true) {
		userInp = getch();
		va_list args;
		va_start(args, argn);
		for( int i=0; i<argn; i++ ){
			if( userInp == va_arg(args, int) ){
				clear();
				va_end(args);
				return userInp;
			}
		}
	}
}

Talent::Talent()
: stat(0), name("N/A"), desc("N/A") {}

Talent::Talent(int s, std::string n, std::string d)
: stat(s), name(n), desc(d) {}

Talent::~Talent(){}

Talent* Talent::GetNext(){
	return next;
}

void Talent::SetNext(Talent* new_next){
	next = new_next;
}

SubTalentTree::SubTalentTree()
: stat(0){
	head = new Talent;
}

SubTalentTree::SubTalentTree(int s)
: stat(s){}

SubTalentTree::~SubTalentTree() {}

void SubTalentTree::AddTalent(std::string name, std::string desc) {
	Talent* temp = head;
	if( head == nullptr ){
		head = new Talent(stat, name, desc);
		return;
	}

	while( temp->GetNext() != nullptr ){
		temp = temp->GetNext();
	}
	temp->SetNext(new Talent(stat, name, desc));
}

void SubTalentTree::PrintTalents(){
	
}

TalentTree::TalentTree() {
	for( int i=0; i<NUM_STATS; i++ ){
		stt[i] = new SubTalentTree(0);
	}
}

TalentTree::~TalentTree() {
	for( int i=0; i<NUM_STATS; i++ ){
		//delete stt[i];
	}
}

void TalentTree::AddTalent(int stat, std::string name, std::string desc){
	stt[stat]->AddTalent(name, desc);
}

PlayerCharacter::PlayerCharacter()
: level(0) {
	for( int i=0; i<NUM_STATS; i++ ){
		stat[i] = 0;
		talent_point[i] = 0;
	}
}

PlayerCharacter::~PlayerCharacter(){
}

void PlayerCharacter::Levelup(){
	GenerateTalentPoints();
	level += 1;
}

void PlayerCharacter::GenerateTalentPoints(){
	for( int i=0; i<NUM_STATS; i++ ){
		int dice_thrown = 0;
		if( stat[i] > 18 ){
			dice_thrown = 6;
		} else if( stat[i] > 16 ){
			dice_thrown = 5;
		} else if( stat[i] > 14 ){
			dice_thrown = 4;
		} else if( stat[i] > 12 ){
			dice_thrown = 3;
		} else if( stat[i] > 10 ){
			dice_thrown = 2;
	} else if( stat[i] > 7 ){
			dice_thrown = 1;
		}

		for( int j=0; j<dice_thrown; j++ ){
			talent_point[i] += rand_num(1, 4);
		}
	}
}

void PlayerCharacter::SetStat(int i, int n){
	stat[i] += n;
}

int PlayerCharacter::GetLevel(){
	return level;
}

int PlayerCharacter::GetStat(int i){
	return stat[i];
}

int PlayerCharacter::GetTalentPoint(int i){
	return talent_point[i];
}

void PrintStatNames(struct Pos pos, int statselected){
	struct Pos new_pos = pos;
	for( int i=0; i<NUM_STATS; i++ ){
		int col = i+1;
		if( i == statselected ){
			col += 7;
		}
		attron(COLOR_PAIR(col));
		mvaddstr(new_pos.y, new_pos.x, STAT_NAMES[i].c_str());
		attroff(COLOR_PAIR(col));
		new_pos.y += STAT_MARGIN_Y;
	}
}

void PrintStatDescription(struct Pos pos, int stat){
	switch( stat ){
	case 0:
		mvprintw(pos.y, pos.x, "Strength determines a characters physical might.");
		break;
	
	case 1:
		mvprintw(pos.y, pos.x, "Dexterity determines a characters reflexes");
		break;
	
	case 2:
		mvprintw(pos.y, pos.x, "Constitution determines a characters vigor");
		break;
	
	case 3:
		mvprintw(pos.y, pos.x, "Intelligence determines a characters mental aptitude");
		break;
	
	case 4:
		mvprintw(pos.y, pos.x, "Wisdom determines a characters mental fortitude");
		break;
	
	case 5:
		mvprintw(pos.y, pos.x, "Charisma determines a characters charm and leadership");
		break;

	case 6:
		mvprintw(pos.y, pos.x, "Luck determines a characters luck");
		break;

	default:
		break;
	}
}

void PrintCurrentLevel(PlayerCharacter player, struct Pos pos){
	mvprintw(pos.y, pos.x, "LEVEL: %i", player.GetLevel());
}

void PrintCurrentStats(Cwin* statwin, PlayerCharacter player, struct Pos pos, int statselected){
	int statx = 0;
	struct Pos new_pos = pos;
	new_pos.x += 3;
	for( int i=0; i<NUM_STATS; i++ ){
		statwin->Moveto({new_pos.y, pos.x});
		statwin->Print();

		if( player.GetStat(i) > 9 )
			statx = -1;
		else
			statx = 0;

		if( i == statselected ){
			attron(COLOR_PAIR(14));
			mvprintw(new_pos.y + 2, new_pos.x + statx, "%i", player.GetStat(i));
			attroff(COLOR_PAIR(14));
		} else
			mvprintw(new_pos.y + 2, new_pos.x + statx, "%i", player.GetStat(i));

		new_pos.y += STAT_MARGIN_Y;
	}
}

void PrintAvailableTalentPoints(PlayerCharacter player, struct Pos pos){
	struct Pos new_pos = pos;
	new_pos.x += 0;
	new_pos.y += 1;
	for( int i=0; i<NUM_STATS; i++ ){
		mvprintw(new_pos.y, new_pos.x, "talent points: %i", player.GetTalentPoint(i));
		new_pos.y += STAT_MARGIN_Y;
	}
}

void StateMachine(TalentTree tt, Cwin* cwin[3], PlayerCharacter& player, AppState& curstate, int& statselected, char& userInp, struct Pos tooltip_pos);
void InitTalents(TalentTree& tt);

void initialize(){
	initscr();
	start_color();
	cbreak();
	noecho();
	curs_set(0);
}

int deinitialize(){
	endwin();
	return 0;
}

int main(){
	initialize();
	init_pair(1, COLOR_RED, COLOR_BLACK);
	init_pair(2, COLOR_GREEN, COLOR_BLACK);
	init_pair(3, COLOR_YELLOW, COLOR_BLACK);
	init_pair(4, COLOR_CYAN, COLOR_BLACK);
	init_pair(5, COLOR_MAGENTA, COLOR_BLACK);
	init_pair(6, COLOR_YELLOW, COLOR_BLACK);
	init_pair(7, COLOR_WHITE, COLOR_BLACK);
	init_pair(8, COLOR_BLACK, COLOR_RED);
	init_pair(9, COLOR_BLACK, COLOR_GREEN);
	init_pair(10, COLOR_BLACK, COLOR_YELLOW);
	init_pair(11, COLOR_BLACK, COLOR_CYAN);
	init_pair(12, COLOR_BLACK, COLOR_MAGENTA);
	init_pair(13, COLOR_BLACK, COLOR_YELLOW);
	init_pair(14, COLOR_BLACK, COLOR_WHITE);

	enum AppState curstate = STATE_STATS;
	int statselected = 0;
	char userInp = '\0';
	TalentTree tt;

	struct Pos screensize = { 0 };
	getmaxyx(stdscr, screensize.y, screensize.x);
	screensize = {screensize.y-2, screensize.x-2};
	Cwin* cwin[3];
	cwin[0] = new Cwin(screensize.y/2, screensize.x, 1, 1);
	cwin[1] = new Cwin(4, 6, 7, 5);
	cwin[2] = new Cwin(30, 5, 20, 3);
	struct Pos tooltip_pos = { screensize.y/2-1, screensize.x/4};

	while( curstate != STATE_EXIT ){
		clear();
		PlayerCharacter player; 
		curstate = STATE_STATS;
		
		while( true ){
			StateMachine(tt, cwin, player, curstate, statselected, userInp, tooltip_pos);
			if( (curstate == STATE_RESET) || (curstate == STATE_EXIT) )
				break;
		}
		if( curstate == STATE_EXIT )
			break;
	}
	return deinitialize();
}

//i1
void StateMachine(TalentTree tt, Cwin* cwin[3], PlayerCharacter& player, AppState& curstate, int& statselected, char& userInp, struct Pos tooltip_pos){
	struct Pos levelpos = { 1, 3 };
	struct Pos statpos = { 3, 5 };
	cwin[0]->Print();
	switch( curstate ){
	case STATE_STATS:
		PrintCurrentLevel(player, levelpos);
		PrintCurrentStats(cwin[1], player, statpos, statselected);
		PrintStatNames(statpos, -1);
		PrintStatDescription(tooltip_pos, statselected);

		userInp = GetUserInp(10, 'h', 'j', 'k', 'l', 'q', 'L', 'R', 't');
		if( userInp == 'q' )
			curstate = STATE_EXIT;
		else if( userInp == 'R' )
			curstate = STATE_RESET;
		else if( userInp == 'L' )
			player.Levelup();
		else if( userInp == 't' ){
			clear();
			refresh();
			curstate = STATE_TALENTS;
		} else if( userInp == 'k' ){
			if( statselected == 0 )
				statselected = NUM_STATS - 1;
			else
				statselected--;
		} else if( userInp == 'j' ){
			if( statselected == NUM_STATS - 1 )
				statselected = 0;
			else
				statselected++;
		} else if( userInp == 'h' ){
			player.SetStat(statselected, -1);
		} else if( userInp == 'l' ){
			player.SetStat(statselected, 1);
		}
		break;
//i1.1
	case STATE_TALENTS:
		PrintCurrentLevel(player, levelpos);
		PrintStatNames(statpos, statselected);
		PrintAvailableTalentPoints(player, statpos);

		userInp = GetUserInp(3, 'j', 'k', 'b');
		if( userInp == 'b' )
			curstate = STATE_STATS;
		else if( userInp == 'k' ){
			if( statselected == 0 )
				statselected = NUM_STATS - 1;
			else
				statselected--;
		} else if( userInp == 'j' ){
			if( statselected == NUM_STATS - 1 )
				statselected = 0;
			else
				statselected++;
		}
		break;

	default:
		break;
	}
}

void InitTalents(TalentTree& tt){
	tt.AddTalent(0, "Puglism", "Unarmed damage.");
	tt.AddTalent(0, "Headhunter", "Throwing damage.");
	tt.AddTalent(0, "Warrior", "Weapon damage.");
	tt.AddTalent(0, "Mule", "Carry weight.");
	tt.AddTalent(0, "Way of the Frog", "Jumping increase.");
	tt.AddTalent(0, "Way of the Ram", "Knockback increase.");
	tt.AddTalent(0, "Nutcracker", "Grip strength.");
	tt.AddTalent(1, "Mist", "Chance to dodge.");
	tt.AddTalent(1, "Exploiter", "Chance for subcrit.");
	tt.AddTalent(1, "Accuracy M.", "Chance to Hit (Melee weapons).");
	tt.AddTalent(1, "Accuracy R.", "Chance to Hit (Ranged weapons).");
	tt.AddTalent(1, "Accuracy T.", "Chance to Hit (Thrown weapons).");
	tt.AddTalent(1, "Speedster", "Movement speed increase.");
	tt.AddTalent(1, "Sealegs", "Chance to maintain balance.");
	tt.AddTalent(1, "Featherfall", "Reduced fall damage.");
	tt.AddTalent(1, "Ballistics", "Increase projectile range.");
	tt.AddTalent(1, "Avoidance", "Increased saving throw on AoE effects.");
	tt.AddTalent(2, "Hearty", "Health increase.");
	tt.AddTalent(2, "Healthy", "Resistance increase (Bleeding, Poison, Disease).");
	tt.AddTalent(2, "Aegis", "Chance to deflect damage type.");
	tt.AddTalent(2, "Mouth Breather", "Reduced DoT from neck Constriction.");
	tt.AddTalent(2, "Drunkard", "Drinking tolerance.");
	tt.AddTalent(2, "Poise", "Resistance to knockback.");
	tt.AddTalent(2, "Castle", "Make yourself cover for allies.");
	tt.AddTalent(3, "Empty Mind", "Buff duration increase.");
	tt.AddTalent(3, "Magician", "All spell damage increase.");
	tt.AddTalent(3, "Accuracy S.", "Chance to Hit (Spells).");
	tt.AddTalent(3, "Firebender", "Fire and Lightning damage increase.");
	tt.AddTalent(3, "Ice Maiden", "Ice damage increase.");
	tt.AddTalent(3, "Necromancer", "Necrotic damage increase.");
	tt.AddTalent(3, "The Faithful", "Radiant damage increase.");
	tt.AddTalent(3, "Melting Man", "Acid damage increase.");
	tt.AddTalent(4, "Strong Mind", "Increase DC spell break saves.");
	tt.AddTalent(4, "Watch Your Step!", "Chance to spot traps passively.");
	tt.AddTalent(4, "Show Yourself!", "Chance to spot hidden movements passively.");
	tt.AddTalent(4, "The Doctor", "Increase spell healing.");
	tt.AddTalent(4, "Druidic", "Increased offensive nature damage.");
	tt.AddTalent(4, "Magic Mirror", "Chance to deflect small magic projectiles.");
	tt.AddTalent(4, "Writer's Block", "Chance to gain insight while crafting.");
	tt.AddTalent(5, "Knock Knock,", "Chance to be funny.");
	tt.AddTalent(5, "Who's There?", "Chance to persuade door.");
	tt.AddTalent(5, "Charge!", "Chance for nearby allies to roll +1 initiative.");
	tt.AddTalent(5, "Attack!", "Chance for nearby allies to increase primary damage stat +1.");
	tt.AddTalent(5, "Hold the Line!", "Chance for nearby allies to increase AC +1.");
	tt.AddTalent(5, "Presence", "Increased threat.");
	tt.AddTalent(5, "Distract", "Chance to decrease threat for one turn.");
	tt.AddTalent(5, "Bully", "psychic damage increase.");
	tt.AddTalent(6, "Luck", "Lucky.");
}
